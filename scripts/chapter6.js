// 6.1

// Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
// Например:
//
// sumTo(1) = 1
// sumTo(2) = 2 + 1 = 3
// sumTo(3) = 3 + 2 + 1 = 6
// sumTo(4) = 4 + 3 + 2 + 1 = 10
// ...
// sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
// Сделайте три варианта решения:
// С использованием цикла.
// Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.
// С использованием формулы арифметической прогрессии.
// Пример работы вашей функции:

// function sumTo(n) {
//     /*... ваш код ... */
//     let result = 0;
//     for (let i = 1; i<=n; i++) {
//         result +=i;
//     }
//     return result;
// }

// function sumTo(n) {
//     /*... ваш код ... */
//     return (n + 1)*(n/2);
// }
// function sumTo(n) {
//     /*... ваш код ... */
//     if (n === 1) return 1;
//     return n + sumTo(n - 1);
// }
//
// alert( sumTo(100) ); // 5050

// -------------------------------------

// Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два",
// и так далее до 1. Факториал n обозначается как n!
// Определение факториала можно записать как:
// n! = n * (n - 1) * (n - 2) * ...*1
// Примеры значений для разных n:
// 1! = 1
// 2! = 2 * 1 = 2
// 3! = 3 * 2 * 1 = 6
// 4! = 4 * 3 * 2 * 1 = 24
// 5! = 5 * 4 * 3 * 2 * 1 = 120
// Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.
//
// alert( factorial(5) ); // 120
// P.S. Подсказка: n! можно записать как n * (n-1)! Например: 3! = 3*2! = 3*2*1! = 6

// function factorial(n) {
//     if (n === 1) return 1;
//     return n * factorial(n - 1);
// }

// -------------------------------------

// Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2.
// То есть, следующее число получается как сумма двух предыдущих.
// Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
// Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.
// Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.
// Пример работы:

// function fib(n) {
//     /* ваш код */
//     let a = 1;
//     let b = 1;
//     for (let i = 3; i <= n; i++) {
//         let c = a + b;
//         a = b;
//         b = c;
//     }
//     return b;
// }
//
// alert(fib(3)); // 2
// alert(fib(7)); // 13
// alert(fib(77)); // 5527939700884757
// P.S. Все запуски функций из примера выше должны работать быстро.
// Вызов fib(77) должен занимать не более доли секунды.

// -------------------------------------

// Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):
// let list = {
//     value: 1,
//     next: {
//         value: 2,
//         next: {
//             value: 3,
//             next: {
//                 value: 4,
//                 next: null
//             }
//         }
//     }
// };
// Напишите функцию printList(list), которая выводит элементы списка по одному.
// Сделайте два варианта решения: используя цикл и через рекурсию.
// Как лучше: с рекурсией или без?

// function printList(list) {
//     if (!list.next) return list.value;
//     return list.value + ', ' + printList(list.next);
// }
// console.log(printList(list))

// -------------------------------------

// 6.3

// Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
// Да, именно таким образом, используя двойные круглые скобки (не опечатка).
// Например:

// function sum(num) {
//     return function (num2) {
//         return num + num2
//     }
// }
// console.log(sum(1)(2)) // = 3
// console.log(sum(5)(-1) )// = 4

// -------------------------------------

// У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f.
// Если она возвращает true, то элемент добавится в возвращаемый массив.
// Сделайте набор «готовых к употреблению» фильтров:
//
// inBetween(a, b) – между a и b (включительно).
// inArray([...]) – находится в данном массиве.
// Они должны использоваться таким образом:

/* .. ваш код для inBetween и inArray */
// let arr = [1, 2, 3, 4, 5, 6, 7];
// arr.filter(inBetween(3,6)) // – выбирает только значения между 3 и 6 (включительно).
//
// arr.filter(inArray([1,2,3])) // – выбирает только элементы, совпадающие с одним из элементов массива
// // Например:
// function inBetween(a, b) {
//     return item => item >= a && item <= b
//
// }
// function inArray(arr) {
//     return item => arr.includes(item)
//
// }
// alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
// alert( arr.filter(inArray([1, 2, 10])) ); // 1,2

// -------------------------------------

// У нас есть массив объектов, который нужно отсортировать:
//
// let users = [
//     { name: "John", age: 20, surname: "Johnson" },
//     { name: "Pete", age: 18, surname: "Peterson" },
//     { name: "Ann", age: 24, surname: "Hathaway" }
// ];
// Обычный способ был бы таким:

// по имени (Ann, John, Pete)
// users.sort((a, b) => a.name > b.name ? 1 : -1);

// по возрасту (Pete, Ann, John)
// users.sort((a, b) => a.age > b.age ? 1 : -1);
// Можем ли мы сделать его короче, скажем, вот таким?

// users.sort(byField('name'));
// users.sort(byField('age'));
// function byField(field) {
//     return (a, b) => a[field] > b[field] ? 1 : -1
// }
// То есть, чтобы вместо функции, мы просто писали byField(fieldName).
// Напишите функцию byField, которая может быть использована для этого.

// -------------------------------------

// 6.6

// Измените код makeCounter() так, чтобы счётчик мог увеличивать и устанавливать значение:
// counter() должен возвращать следующее значение (как и раньше).
// counter.set(value) должен устанавливать счётчику значение value.
// counter.decrease() должен уменьшать значение счётчика на 1.
// Посмотрите код из песочницы с полным примером использования.
// P.S. Для того, чтобы сохранить текущее значение счётчика, можно воспользоваться как замыканием,
// так и свойством функции. Или сделать два варианта решения: и так, и так.
// function makeCounter() {
//     let count = 0;
//     function counter() {
//         return count++;
//     }
//     counter.set = function (value) {
//         count = value;
//     }
//     counter.decrease = function () {
//         count--;
//     }
//     return counter;
// }

// -------------------------------------

// Напишите функцию sum, которая бы работала следующим образом:
// sum(1)(2) // == 3; // 1 + 2
// sum(1)(2)(3) // == 6; // 1 + 2 + 3
// sum(5)(-1)(2) // == 6
// sum(6)(-1)(-2)(-3) // == 0
// console.log(sum(0)(1)(2)(3)(4)(5).getValue()) // == 15
// // P.S. Подсказка: возможно вам стоит сделать особый метод преобразования в примитив для функции.
//
// function sum(a) {
//     let summ = 0;
//     function func(b) {
//         summ += b;
//         return func;
//     }
//     func.getValue = () => summ;
//     return func;
// }

// -------------------------------------

// 6.8

// Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.
// Сделайте два варианта решения.
// Используя setInterval.
// Используя рекурсивный setTimeout.

// function printNumbers(from, to) {
//     let current = from;
//     setInterval(() => {
//         if (current <= to) {
//             console.log(current);
//             current++;
//         }
//     }, 1000)
// }

// function printNumbers(from, to) {
//     let time = 1
//     for(let i = from; i <= to; i++) {
//         setTimeout(() => console.log(i), time*1000)
//         time++;
//     }
// }
// printNumbers(1, 6)
// -------------------------------------

// 6.9


// Создайте декоратор spy(func), который должен возвращать обёртку,
// которая сохраняет все вызовы функции в своём свойстве calls.
// Каждый вызов должен сохраняться как массив аргументов.
// Например:

// function work(a, b) {
//     alert( a + b ); // произвольная функция или метод
// }
//
// work = spy(work);
//
// work(1, 2); // 3
// work(4, 5); // 9

// for (let args of work.calls) {
//     alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
// }
//
// function spy(f) {
//     function wrapper(...args) {
//         wrapper.calls.push(args);
//         return f.apply(this, arguments);
//     }
//     wrapper.calls = [];
//     return wrapper;
// }

// -------------------------------------

// Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. Например:

// function f(x) {
//     alert(x);
// }

// создаём обёртки
// let f1000 = delay(f, 1000);
// let f1500 = delay(f, 1500);
//
// function delay(f, ms) {
//     return function wrapper() {
//         setTimeout(() => f.apply(this, arguments), ms);
//     }
// }
//
// f1000("test"); // показывает "test" после 1000 мс
// f1500("test"); // показывает "test" после 1500 мс
// Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».
//
// В приведённом выше коде f – функция с одним аргументом, но ваше решение должно
// передавать все аргументы и контекст this.

// -------------------------------------

// Результатом декоратора debounce(f, ms) должна быть обёртка, которая передаёт
// вызов f не более одного раза в ms миллисекунд. Другими словами, когда мы вызываем
// debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.
// Например:

// let f = debounce(alert, 1000);
//
// f(1); // выполняется немедленно
// f(2); // проигнорирован
//
// setTimeout( () => f(3), 100); // проигнорирован (прошло только 100 мс)
// setTimeout( () => f(4), 1100); // выполняется
// setTimeout( () => f(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
// На практике debounce полезен для функций, которые получают/обновляют данные, и мы знаем,
// что повторный вызов в течение короткого промежутка времени не даст ничего нового.
// Так что лучше не тратить на него ресурсы.

// function debounce(f, ms) {
//     let isReady = true;
//     return function() {
//         if (!isReady) return;
//         f.apply(this, arguments);
//         isReady = false;
//         setTimeout(() => isReady = true, ms);
//     };
// }

// -------------------------------------

// Вызов askPassword() в приведённом ниже коде должен проверить пароль и
// затем вызвать user.loginOk/loginFail в зависимости от ответа.
// Однако, его вызов приводит к ошибке. Почему?
// Исправьте выделенную строку, чтобы всё работало (других строк изменять не надо).

// function askPassword(ok, fail) {
//     let password = prompt("Password?", '');
//     if (password == "rockstar") ok();
//     else fail();
// }
//
// let user = {
//     name: 'Вася',
//
//     loginOk() {
//         alert(`${this.name} logged in`);
//     },
//
//     loginFail() {
//         alert(`${this.name} failed to log in`);
//     },
//
// };
//
// askPassword(user.loginOk, user.loginFail);
// askPassword(user.loginOk.bind(user), user.loginFail.bind(user));

// -------------------------------------

// Это задание является немного усложнённым вариантом одного из предыдущих – Исправьте функцию, теряющую "this".
// Объект user был изменён. Теперь вместо двух функций loginOk/loginFail у него есть
// только одна – user.login(true/false).
// Что нужно передать в вызов функции askPassword в коде ниже, чтобы она могла вызывать
// функцию user.login(true) как ok и функцию user.login(false) как fail?

// function askPassword(ok, fail) {
//     let password = prompt("Password?", '');
//     if (password == "rockstar") ok();
//     else fail();
// }
//
// let user = {
//     name: 'John',
//
//     login(result) {
//         alert( this.name + (result ? ' logged in' : ' failed to log in') );
//     }
// };
//
// askPassword(user.login.bind(user, true), user.login.bind(user, false)); // ?
// Ваши изменения должны затрагивать только выделенный фрагмент кода.
