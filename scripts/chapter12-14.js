// 12

// Есть много областей, где нам нужны случайные данные.
// Одной из них является тестирование. Нам могут понадобиться случайные данные: текст, числа и т.д.,
// чтобы хорошо всё проверить.
// В JavaScript мы можем использовать Math.random(). Но если что-то пойдёт не так, то нам нужно
// будет перезапустить тест, используя те же самые данные.
// Для этого используются так называемые «сеяные псевдослучайные генераторы». Они получают «зерно»,
// как первое значение, и затем генерируют следующее, используя формулу. Так что одно и то же зерно даёт одинаковую последовательность, и, следовательно, весь поток легко воспроизводим. Нам нужно только запомнить зерно, чтобы воспроизвести последовательность.
// Пример такой формулы, которая генерирует более-менее равномерно распределённые значения:
// next = previous * 16807 % 2147483647
// Если мы используем 1 как зерно, то значения будут:

// 16807
// 282475249
// 1622650073
// …и так далее…
// Задачей является создать функцию-генератор pseudoRandom(seed), которая получает seed и создаёт
// генератор с указанной формулой.

// Пример использования:

// let generator = pseudoRandom(1);
//
// alert(generator.next().value); // 16807
// alert(generator.next().value); // 282475249
// alert(generator.next().value); // 1622650073
//
// function pseudoRandom(seed) {
//     let random = seed;
//     return function() {
//         random = random * 16807 % 2147483647;
//         return random;
//     }
// }

// -------------------------------------

// 13
// Обычно при чтении несуществующего свойства из объекта возвращается undefined.
// Создайте прокси, который генерирует ошибку при попытке прочитать несуществующее свойство.
// Это может помочь обнаружить программные ошибки пораньше.
// Напишите функцию wrap(target), которая берёт объект target и возвращает прокси,
// добавляющий в него этот аспект функциональности.
// Вот как это должно работать:

// let user = {
//     name: "John"
// };
//
// function wrap(target) {
//     return new Proxy(target, {
//         /* ваш код */
//         get(target, prop, receiver) {
//             if (prop in target) {
//                 return Reflect.get(target, prop, receiver);
//             } else {
//                 throw new ReferenceError(`Свойство не существует: "${prop}"`)
//             }
//         }
//     });
// }
//
// user = wrap(user);
//
// alert(user.name); // John
// alert(user.age); // Ошибка: такого свойства не существует

// -------------------------------------

// В некоторых языках программирования возможно получать элементы массива, используя
// отрицательные индексы, отсчитываемые с конца.
// Вот так:
//
// let array = [1, 2, 3];
//
// array[-1]; // 3, последний элемент
// array[-2]; // 2, предпоследний элемент
// array[-3]; // 1, за два элемента до последнего
// Другими словами, array[-N] – это то же, что и array[array.length - N].
// Создайте прокси, который реализовывал бы такое поведение.
// Вот как это должно работать:

// let array = [1, 2, 3];
// array = new Proxy(array, {
//     /* ваш код */
//     get(target, prop, receiver) {
//         if (prop < 0) {
//             prop = +prop + target.length;
//         }
//         return Reflect.get(target, prop, receiver);
//     }
// });
//
// alert( array[-1] ); // 3
// alert( array[-2] ); // 2

// -------------------------------------

// Создайте калькулятор, который запрашивает ввод какого-нибудь арифметического выражения
// и возвращает результат его вычисления.
// В этой задаче нет необходимости проверять полученное выражение на корректность, просто
// вычислить и вернуть результат.

// const code = prompt("Выражение:", '2+2');
// console.log(eval(code))

// -------------------------------------
// 14
// Напишите функцию isInteger(num), которая возвращает true, если num – целое число, иначе false.
// Например:

// alert( isInteger(1) ); // true
// alert( isInteger(1.5) ); // false
// alert( isInteger(-0.5) ); // false
//
// function isInteger(num) {
//     return (num ^ 0) === num;
// }
